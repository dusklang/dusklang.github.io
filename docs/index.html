<!DOCTYPE html>
<html>
    <head>
        <title>Dusk Blog</title>
        <link rel="stylesheet" type="text/css" href="style.css">
    </head>
    <body>
        <div class="header">
            <h1>Dusk Blog</h1>
        </div>
        <div class="content-container">
            <div class="content">
                <h1>The Dusk Programming Language</h1>
                <h2>Introduction</h2>
                My name is Zach Wolfe. I started building Dusk for the same reason many things are built: I was frustrated with the alternatives. Every language I have ever tried has some aspects I appreciate, and others that drive me up the wall. My goal with Dusk is two-fold: one, to make a language that enables me to build high-quality software with as little frustration&mdash;and as much assistance&mdash;as possible, and two, to make the compiler and associated tools as high-quality as possible.

                <p style="color:red">Note: neither this blog nor the language it is about are ready for prime-time. In fact, the compiler is not even released yet. On the off chance that someone has discovered this blog on their own, please stay tuned for an official announcement!</p>

                <h2>What is high-quality software?</h2>
                There are many different kinds of software, and each one will have its own priorities; for example, a mobile application should use as little energy as possible in order to preserve battery life, while a photorealistic 3D game might want trade off energy usage in exchange for better graphics and/or framerate. Still, there are guidelines that I believe can and should be applied to all software, from embedded systems and kernels, to AAA video games, to social media websites. Practical realities of making software sometimes interfere with these guidelines, and by no means do I claim to be better at following them than anyone reading this. These are simply ideals that I believe all of us programmers (including myself) should strive towards, and Dusk should make easier to do so.
                <ul>
                    <li><b>Don't use more of the computer's resources than you need</b>: Modern computers are incredibly powerful, but they are not infinite. Use of resources including memory, persistent storage, CPU and GPU time and energy should be limited to only what is necessary to solve the problem at hand. By this guideline, an application that uses less of these resources is higher quality than one that uses more, all else being equal.</li>
                    <li><b>Don't use more of the <i>user's</i> resources than you need</b>: Even more valuable&mdash;and more limited&mdash;than the computer's resources are those of the humans using them.
                        <ul>
                            <li>Do not make them wait for anything without a very good reason. In cases where there is unavoidable latency, such as expensive computations or contacting a remote server, make every effort to hide this latency.</li>
                            <li>Do not test their patience with hard-to-understand or misleading interfaces.</li>
                        </ul>
                    </li>
                    <li><b>Do The Right Thing when possible:</b>
                        <ul>
                            <li>GUI applications should use one of the native UI libraries offered by the OS vendor, and follow the conventions of each OS they are targeting. For example, classic Win32 calls or WinUI on Windows, UIKit or SwiftUI on iOS, etc. Cross-platform UI libraries can be useful tools, but only insofar as they enable the exact same native apps that follow OS conventions to made with less code. Make no mistake: doing this on more than one platform is <i>much harder</i> than using Electron! There is only so much a programming language can do here, but I hope Dusk's features will enable a UI library that makes this a much more viable option.</li>
                            <li>Accessibility is very important.</li>
                        </ul>
                    </li>
                    <li><b>Do not drop frames.</b> All apps should run at a buttery smooth framerate, without stutter or inconsistent frame pacing.</li>
                    <li><b><i>Do</i> write reliable, bug-free software (with help).</b> Your compiler and associated tools should do everything they can to detect and notify you of bugs before you ship.</li>
                </ul>
                This is far from an exhaustive list; for one thing, many problems in software (such as invasive advertising) come down to business decisions, which are largely out of scope for any individual programmer or programming language to solve. But I think this will provide a good foundation for what I mean when I say "high-quality software."

                <h2>What is Dusk?</h2>
                As I mentioned, Dusk aims to both <i>be</i> high-quality software, as well as enable its users to write their own. I believe the best way to do this is to stay relatively close to the hardware. Given a problem statement and a target platform, there exists at least one ideal sequence of machine code instructions to solve that problem. Dusk's job is to guide you to something resembling that sequence as quickly as possible. That does not mean that you can't express high-level abstractions in Dusk, it just means that the language must not stand in the way from you taking full advantage of the hardware when you need to. Dusk is a compiled, imperative language, and is influenced by many other languages. Its syntax is similar to <a href="https://rust-lang.org/">Rust</a> in a lot of ways. Its type system takes cues from <a href="https://swift.org/">Swift</a>'s, though without falling victim to the <a href="https://www.cocoawithlove.com/blog/2016/07/12/type-checker-issues.html">exponential time</a> issues that that language has. Other influences include <a href="https://www.circle-lang.org/">Circle</a>, <a href="https://ziglang.org/">Zig</a>, <a href="http://odin-lang.org/">Odin</a>, and <a href="https://youtu.be/uZgbKrDEzAs">Jai</a>.

                <h3>Functions</h3>
                The <code>fn</code> keyword declares a function. Here is an example of a <code>main</code> function, which will be run immediately on startup.
                <pre class="code">
                fn main() {
                    print("Hello, world!\n")
                }
                </pre>

                <p>
                To be continued...

                <h1>Interop Part 1: Introduction</h1>
                <h2>What is interop?</h2>
                By interop (short for interoperability), I really mean two separate but related things: first, from Dusk, I want to be able to painlessly call into APIs written in other languages and runtimes. Second, from other languages, I want to be able to call into APIs implemented and/or declared in Dusk. There are three main reasons you might want to do this. First, there are a lot of libraries out there, and almost none of them are written in Dusk. So it would be nice if we could use them. Second, it would be nice to be able to seamlessly integrate Dusk into an existing project, either by rewriting parts of it or by writing new parts in Dusk, for the benefits that could provide. Third, we must be able to call into the native OS APIs, which unsurprisingly are not provided in Dusk. Note that is also quite common for such APIs to need to call back into our code, so this requires both sides of interop mentioned above (calling and being called). For now, I am going to focus on this third reason for interop, calling into the OS, because I think it is by far the most important the short term than calling third-party code, and furthermore, making progress on it will also help with eventually solving the others.

                <h2>Calling into the OS in 2022</h2>
                There is disappointingly little in common between the major operating systems, in terms of the work needed to call into their core APIs. All of them have at least some C APIs, so that makes for a natural starting point in most case. But the rest is all different. This isn't going to be easy.

                <h3>Windows</h3>
                For the last few years, Windows has been my primary operating system, so I will start there because it's what I am most familiar with. First, the good news: a large number of APIs in Windows rely on nothing but plain C, so as long as we can import them and respect Microsoft's C ABI, we should be in good shape. Or at least we would be, if we used the same compilation model as C.

                <h4>C</h4>

                <h5>Problem 1: Where are the functions?</h5>
                Microsoft's C APIs are declared in headers distributed with their SDK. These APIs are implemented in <a href="https://en.wikipedia.org/wiki/Dynamic-link_library">DLLs</a> distributed with the operating system. A typical executable or DLL will define a list of DLLs it <a href="https://docs.microsoft.com/en-us/cpp/build/linking-an-executable-to-a-dll">implicitly</a> depends on, and for each one, which functions it might call. When your program is launched, the OS' loader will map all the DLLs you need into your address space, and populate the addresses to each function.
                
                <p>
                Even though your program imports DLLs, that is somewhat counterintuitively <i>not</i> how those imports are described at link time. Instead, Microsoft long ago inserted another layer of indirection: import libraries. So, to call functions from <code>kernel32.dll</code> for example, you would actually specify <code>kernel32.lib</code> to the linker. The entire purpose of these lib files is to specify a list of exports that come from a DLL&mdash;a list of exports that the DLLs themselves also must have. So why do they exist? Historically there were <a href="https://devblogs.microsoft.com/oldnewthing/20060718-32/?p=30483">good reasons</a>, mainly concerning efficiency. But crucially for our purposes, they are distributed with the SDK, unlike the DLLs they refer to. This means with a little work, we can download and extract the SDK on any platform&mdash;not just Windows&mdash;enabling cross-compilation.

                <h5>Problem 2: What if the functions don't exist?</h5>
                This is probably not news to anybody, but there are many versions of Windows.

                <h4>COM</h4>

                <h4>WinRT</h4>

                <h4>Footnote: C# and the CLR</h4>
                In my limited understanding, Microsoft's <a href="https://docs.microsoft.com/en-us/dotnet/standard/clr">common language runtime</a> (abbreviated CLR) does not unlock any APIs that the previous technologies don't already. Therefore, I can't justify spending time implementing CLR interop at this time.

                <h3>Apple platforms (iOS, iPadOS, macOS, watchOS, tvOS, etc.)</h3>
                Apple uses a consistent set of technologies across their many operating systems, so it makes sense to consider them all together.

                <h4>C</h4>

                <h4>Objective-C</h4>

                <h4>Swift</h4>

                <h3>Android</h3>

                <h4>Java and the JVM</h4>
                Android is something of a special case: unlike all the platforms I've discussed so far, most of the core Android APIs are not exposed as native APIs. Instead, it is expected that you write most of your app in Java or Kotlin, which is compiled down to <a href="https://en.wikipedia.org/wiki/Java_bytecode">Java bytecode</a>, which is then transformed again into <a href="https://source.android.com/devices/tech/dalvik/dalvik-bytecode">Dalvik bytecode</a>, which is finally distributed as-is to your user's devices and interpreted and/or compiled. Since so many of the APIs that apps rely on are exposed only to the JVM, Dusk's typical approach of compiling solely to native machine code is suboptimal for Android (for reasons that I will soon go into). Therefore, I wrote (actually, "will have written before this article is officially posted" is more accurate) a Dalvik bytecode backend for Dusk.

                <h4>Kotlin</h4>
                Talk about how Kotlin keeps adding new features that are not backwards-compatible with Java, and Google keeps using them in their APIs.

                <h4>C and the JNI</h4>
                Talk about the lower-level APIs that actually provide native versions, e.g., audio.

                <h4>Bringing it all together: a hybrid approach</h4>
                Talk about the plan to compile some parts of the app to native code, others to bytecode, and the interfaces between them.

                <h3>Linux</h3>
                The good news is that all essential Linux APIs are either syscalls or C functions from dynamic libraries. So there are no additional languages or runtimes to implement here! Yippee!

                <p>The bad news is that
            </div>
        </div>
    </body>
</html>